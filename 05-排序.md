## 排序算法

### 总览

排序就是一系列数据，按照某个关键字（例如：销量，价格），进行递增或者递减的顺序排列起来。在平常的项目中，我们也经常会用到排序。排序非常 重要，常见经典排序方法有：冒泡排序、插入排序、选 择排序、归并排序、快速排序、计数排序、基数排序、桶排序等。

针对排序算法的空间复杂度，我们还引入了一个新的概念，原地排序（Sorted in place）。 原地排序算法，就是特指空间复杂度是 O(1) 的排序算法。

针对排序算法，我们还有一个 重要的度量指标，稳定性。这个概念是说，如果待排序的序列中存在值相等的元素，经过排 序之后，相等元素之间原有的先后顺序不变。

常见排序事件复杂度和稳定性对照表：

| 排序算法 |     平均时间     | 稳定性 |
| :------: | :--------------: | :----: |
| 希尔排序 | O(n<sup>2</sup>) |  稳定  |
| 冒泡排序 | O(n<sup>2</sup>) |  稳定  |
| 插入排序 | O(n<sup>2</sup>) |  稳定  |
| 选择排序 | O(n<sup>2</sup>) | 不稳定 |
| 快速排序 |     O(nlogn)     | 不稳定 |
| 归并排序 |     O(nlogn)     |  稳定  |
| 计数排序 |       O(N)       |  稳定  |
| 基数排序 |       O(N)       |  稳定  |
|  桶排序  |       O(N)       |  稳定  |

### 冒泡排序（Bubble Sort）

定义：冒泡排序只会操作相邻的两个数据。每次冒泡操作都会对相邻的两个元素进行比较，看是否 满足大小关系要求。如果不满足就让它俩互换。

我们举个例子：有一组 数据 9 6 7 5 8 2 1，需要进行冒泡排序，演示图如下：

![](https://myvoice1.oss-cn-beijing.aliyuncs.com/github/sjjg/maopao.jpg)

冒泡排序算法的原理比较容易理解，根据冒泡原理和上图所示给出核心代码：

```go
//冒泡排序算法
func bubbleSort(data []int) {
	arrLen := len(data)
	if arrLen <= 1 {
		return
	}
	for i := 0; i < arrLen; i++ {
		isChange := false //是否有数据交换
		for j := 0; j < arrLen-i-1; j++ {
			if data[j] > data[j+1] {
				data[j], data[j+1] = data[j+1], data[j]
				isChange = true
			}
		}
		//无数据交换 提交结束
		if isChange == false {
			break
		}
	}
}
```

根据上述规则可以得出：

- 冒泡的过程只涉及相邻数据的交换操作，只需要常量级的临时空间，所以它的空间复杂度为 O(1)，是一个原地排序算法。
- 在冒泡排序中，只有交换才可以改变两个元素的前后顺序。为了保证冒泡排序算法的稳定 性，当有相邻的两个元素大小相等的时候，我们不做交换，相同大小的数据在排序前后不会 改变顺序，所以冒泡排序是稳定的排序算法
- 次冒泡操作，最好情况时间复杂度是 O(n)， 以最坏情况时间复杂度为 O(n<sup>2</sup> ），平均时间复杂为：O(n<sup>2</sup>）

平均时间复杂度推导过程会用到概率论的定量分析，这样就使得平均时间复杂度推导难度大大最加，这边可以使用有序度方案解决，有序度方案来源于极客时间教程，满有序度= n*(n-1)/2，逆序度=满有序度–初始有序度； 初始有序度可以采取：n*(n-1)/4， 换句话说，平均情况下，需要 n*(n-1)/4 次交换操作，比较操作肯定要比交换操作多，而复 杂度的上限是 O(n<sup>2</sup>)，所以平均情况下的时间复杂度就是 O(n<sup>2</sup>)。

### 插入排序（Insertion Sort）