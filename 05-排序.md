## 排序算法

### 总览

排序就是一系列数据，按照某个关键字（例如：销量，价格），进行递增或者递减的顺序排列起来。在平常的项目中，我们也经常会用到排序。排序非常 重要，常见经典排序方法有：冒泡排序、插入排序、选 择排序、归并排序、快速排序、计数排序、基数排序、桶排序等。

针对排序算法的空间复杂度，我们还引入了一个新的概念，原地排序（Sorted in place）。 原地排序算法，就是特指空间复杂度是 O(1) 的排序算法。

针对排序算法，我们还有一个 重要的度量指标，稳定性。这个概念是说，如果待排序的序列中存在值相等的元素，经过排 序之后，相等元素之间原有的先后顺序不变。

常见排序事件复杂度和稳定性对照表：

| 排序算法 |     平均时间     | 稳定性 |
| :------: | :--------------: | :----: |
| 希尔排序 | O(n<sup>2</sup>) |  稳定  |
| 冒泡排序 | O(n<sup>2</sup>) |  稳定  |
| 插入排序 | O(n<sup>2</sup>) |  稳定  |
| 选择排序 | O(n<sup>2</sup>) | 不稳定 |
| 快速排序 |     O(nlogn)     | 不稳定 |
| 归并排序 |     O(nlogn)     |  稳定  |
| 计数排序 |       O(N)       |  稳定  |
| 基数排序 |       O(N)       |  稳定  |
|  桶排序  |       O(N)       |  稳定  |

### 冒泡排序（Bubble Sort）

定义：冒泡排序只会操作相邻的两个数据。每次冒泡操作都会对相邻的两个元素进行比较，看是否 满足大小关系要求。如果不满足就让它俩互换。

我们举个例子：有一组 数据 9 6 7 5 8 2 1，需要进行冒泡排序，演示图如下：

![](https://myvoice1.oss-cn-beijing.aliyuncs.com/github/sjjg/maopao.jpg)

冒泡排序算法的原理比较容易理解，根据冒泡原理和上图所示给出核心代码：

```go
//冒泡排序算法
func bubbleSort(data []int) {
	arrLen := len(data)
	if arrLen <= 1 {
		return
	}
	for i := 0; i < arrLen; i++ {
		isChange := false //是否有数据交换
		for j := 0; j < arrLen-i-1; j++ {
			if data[j] > data[j+1] {
				data[j], data[j+1] = data[j+1], data[j]
				isChange = true
			}
		}
		//无数据交换 提交结束
		if isChange == false {
			break
		}
	}
}
```

根据上述规则可以得出：

- 冒泡的过程只涉及相邻数据的交换操作，只需要常量级的临时空间，所以它的空间复杂度为 O(1)，是一个原地排序算法。
- 在冒泡排序中，只有交换才可以改变两个元素的前后顺序。为了保证冒泡排序算法的稳定 性，当有相邻的两个元素大小相等的时候，我们不做交换，相同大小的数据在排序前后不会 改变顺序，所以冒泡排序是稳定的排序算法
- 次冒泡操作，最好情况时间复杂度是 O(n)， 以最坏情况时间复杂度为 O(n<sup>2</sup> ），平均时间复杂为：O(n<sup>2</sup>）

平均时间复杂度推导过程会用到概率论的定量分析，这样就使得平均时间复杂度推导难度大大最加，这边可以使用有序度方案解决，有序度方案来源于极客时间教程，满有序度= n*(n-1)/2，逆序度=满有序度–初始有序度； 初始有序度可以采取：n*(n-1)/4， 换句话说，平均情况下，需要 n*(n-1)/4 次交换操作，比较操作肯定要比交换操作多，而复 杂度的上限是 O(n<sup>2</sup>)，所以平均情况下的时间复杂度就是 O(n<sup>2</sup>)。

### 插入排序（Insertion Sort）

定义： 插入排序，一般也被称为直接插入排序。对于少量元素的排序，它是一个有效的算法 [1] 。插入排序是一种最简单的[排序]方法，它的基本思想是将一个记录插入到已经排好序的有序表中，从而一个新的、记录数增1的有序表。在其实现过程使用双层循环，外层循环对除了第一个元素之外的所有元素，内层循环对当前元素前面有序表进行待插入位置查找，并进行移动。

根据之前的操作方法一样，有一组 数据  9 6 5 8 2 1，需要进行插入排序，演示图如下：

![](https://myvoice1.oss-cn-beijing.aliyuncs.com/github/sjjg/zjpx.jpg)

插入排序算法的原理比较容易理解，根据插入原理和上图所示给出核心代码：

```go
//插入排序算法
func insertionSort(data []int) {
	len := len(data)
	if len <= 1 {
		return
	}
	for i := 1; i < len; i++ {
		value := data[i]
		j := i - 1
		for ; j >= 0; j-- {
			if data[j] > value {
				data[j+1] = data[j] //移动数据
			} else {
				break
			}
		}
		data[j+1] = value //插入数据
	}
}
```

根据上述规则可以得出：

- 在插入排序中，对于值相同的元素，我们可以选择将后面出现的元素，插入到前面出现元素 的后面，这样就可以保持原有的前后顺序不变，所以插入排序是稳定的排序算法。
- 如果要排序的数据已经是有序的，我们并不需要搬移任何数据。如果我们从尾到头在有序数 据组里面查找插入位置，每次只需要比较一个数据就能确定插入的位置。所以这种情况下， 最好是时间复杂度为 O(n)。注意，这里是从尾到头遍历已经有序的数据。
  如果数组是倒序的，每次插入都相当于在数组的第一个位置插入新的数据，所以需要移动大 量的数据，所以最坏情况时间复杂度为 O(n<sup>2</sup>)。
  还记得我们在数组中插入一个数据的平均时间复杂度是多少吗？没错，是 O(n)。所以，对 于插入排序来说，每次插入操作都相当于在数组中插入一个数据，循环执行 n 次插入操 作，所以平均时间复杂度为 O(n<sup>2</sup>)。
- 从实现过程可以很明显地看出，插入排序算法的运行并不需要额外的存储空间，所以空间复 杂度是 O(1)，也就是说，这是一个原地排序算法。

### 选择排序（Selection Sort）

定义：每一次从待排序的数据元素中选出最小（或最大）的一个元素，存放在序列的起始位置，直到全部待排序的数据元素排完。

