## 数组与链表

### 数组

几乎所有的编程语言都原生支持数组类型,因为数组是最简单的内存数据结构， 数 组（Array）是一种**线性表**数据结构。它用一组连续的内存空间，来存储一组具有相同类型 的数据。

从数据结构层面上来看，数据结构可以分为 **线性表 ** 和 **非线性表** 两种。线性表就是数据排成像一条线一样的结构，每个 线性表上的数据最多只有前和后两个方向，线性表结构包括 数组、链表、栈、队列等。非线性表数据之间并不是简单的前后关系，它的结构包括 树、图、堆等。

#### 数据访问

数组根据下标**随机访问**数组元素非常高效，这个得益于数组的是连续的内存空间和相同类型的数据。但有利就有弊，这两个限制也让数组的很多操作变得非常低 效，比如要想在数组中删除、插入一个数据，为了保证连续性，就需要做大量的数据搬移工作。

我们拿一个长度为 5 的 int类型数组 `var a[5]int` 来举例，在我的图中，计算机给 数组 a 分配的了一块连续内存空间 1000 - 1019，其中内存块首地址 base_address = 1000

![](https://myvoice1.oss-cn-beijing.aliyuncs.com/github/sjjg/array_model.png)

我们知道，计算机会给每个内存单元分配一个地址，计算机通过地址来访问内存中的数据。 当计算机需要随机访问数组中的某个元素时，它会首先通过下面的寻址公式，计算出该元素 存储的内存地址：

> a[i]_address = base_address  + i *  data_size

其中 data_size表示数组中每个元素的大小。我们举的这个例子里，数组中存储的是 int 类型数据，所以 data_size 就为 4 个字节。

复杂度分析下：数组支持随机访问，根据寻址公式通过下标随机访问的时间复杂度为 O(1)。如果不是通过随机访问的方式来查找的数据的话，用二分查找，时间复杂度也是 O(logn)。

#### 低效的数据删除和插入

先来看看 **插入操作**，假如有个数组，有6个元素，分别为 {A,B,C,D,E,F} 需要在C位置插入X元素，如下图：

![](https://myvoice1.oss-cn-beijing.aliyuncs.com/github/sjjg/array_insert.png)

可以看出，插入这个X操作，需要元素C D  E F分别往后位置移动一位，所以插入操作之所以低效，就是因为涉及到元素的搬迁问题。
我们来进行复杂度分析下，假如一个单位为n的数组， 在最好的情况下，在数组尾部插入一个元素，只需要操作一次并且不涉及搬迁，所以最好的时间复杂度为 O(1) , 在最坏的情况下，在数组头部插入一个元素，需要搬迁元素N次，最坏的事件复杂度为 O(n), 那因为我们在每个位置插入元素的概率是一样的，所以平均情况时间复杂度为 (1+2+ …n)/n=O(n)

另外在一个特点的情况下，如果数组不需要保持原有元素的有序位置，我们可以将插入位置存放新元素，将以前的插入点旧元素放置数组尾部，例如前图面里面中，我们将数组变换为 A->B->X->D->E->F->C  ，这样的情况，时间复杂度可以将为 O(1)

我们再来看看 **删除操作**

跟插入数据类似，如果我们要删除第 k 个位置的数据，为了内存的连续性，也需要搬移数 据，不然中间就会出现空洞，内存就不连续了。

和插入类似，如果删除数组末尾的数据，则最好情况时间复杂度为 O(1)；如果删除开头的 数据，则最坏情况时间复杂度为 O(n)；平均情况时间复杂度也为 O(n)。

那么怎么样能够减少数组删除的次数和降低数组删除的时间复杂度呢？

**<font color=#FF0000 >我们可以采取类似JVM的机制来处理，先将需要删除的元素标记为删除状态，但并未实际的物理删除和搬移数据，等数组没有更多空间了，再进行一次性删除和搬移。</font>**

### 链表

链表是由一组节点组成的集合。每个节点包括两个部分：一个是存储数据元素的数据域，另一个是存储下一个结点地址的指针域。每个节点都使用一个对象的引用指向它的后继，最后一个节点的指针指向NULL。

链表不需要提前分配固定大小存储空间，当需要存储数据的时候分配一块内存并将这块内存插入链表中。

<img src="https://myvoice1.oss-cn-beijing.aliyuncs.com/github/sjjg/link-array.jpg" style="zoom:50%;" />

从图中我们看到，数组需要一块连续的内存空间来存储， 对内存的要求比较高。如果我们申请一个 100MB 大小的数组，当内存中没有连续的、足够 大的存储空间时，即便内存的剩余总可用空间大于 100MB，仍然会申请失败。而链表恰恰相反，它并不需要一块连续的内存空间，它通过“指针”将一组零散的内存块串 联起来使用，所以如果我们申请的是 100MB 大小的链表，根本不会有问题。

今天重点介绍三种最常见的链表结构，它们分别是：单链表、双 向链表和循环链表:

#### 单链表

