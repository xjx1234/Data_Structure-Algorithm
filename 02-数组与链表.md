## 数组与链表

### 数组

几乎所有的编程语言都原生支持数组类型,因为数组是最简单的内存数据结构， 数 组（Array）是一种**线性表**数据结构。它用一组连续的内存空间，来存储一组具有相同类型 的数据。

从数据结构层面上来看，数据结构可以分为 **线性表 ** 和 **非线性表** 两种。线性表就是数据排成像一条线一样的结构，每个 线性表上的数据最多只有前和后两个方向，线性表结构包括 数组、链表、栈、队列等。非线性表数据之间并不是简单的前后关系，它的结构包括 树、图、堆等。

#### 数据访问

数组根据下标**随机访问**数组元素非常高效，这个得益于数组的是连续的内存空间和相同类型的数据。但有利就有弊，这两个限制也让数组的很多操作变得非常低 效，比如要想在数组中删除、插入一个数据，为了保证连续性，就需要做大量的数据搬移工作。

我们拿一个长度为 5 的 int类型数组 `var a[5]int` 来举例，在我的图中，计算机给 数组 a 分配的了一块连续内存空间 1000 - 1019，其中内存块首地址 base_address = 1000

![](https://myvoice1.oss-cn-beijing.aliyuncs.com/github/sjjg/array_model.png)

我们知道，计算机会给每个内存单元分配一个地址，计算机通过地址来访问内存中的数据。 当计算机需要随机访问数组中的某个元素时，它会首先通过下面的寻址公式，计算出该元素 存储的内存地址：

> a[i]_address = base_address  + i *  data_size

其中 data_size表示数组中每个元素的大小。我们举的这个例子里，数组中存储的是 int 类型数据，所以 data_size 就为 4 个字节。

复杂度分析下：数组支持随机访问，根据寻址公式通过下标随机访问的时间复杂度为 O(1)。如果不是通过随机访问的方式来查找的数据的话，用二分查找，时间复杂度也是 O(logn)。

#### 低效的数据删除和插入

先来看看 **插入操作**，假如有个数组，有6个元素，分别为 {A,B,C,D,E,F} 需要在C位置插入X元素，如下图：

![](https://myvoice1.oss-cn-beijing.aliyuncs.com/github/sjjg/array_insert.png)

可以看出，插入这个X操作，需要元素C D  E F分别往后位置移动一位，所以插入操作之所以低效，就是因为涉及到元素的搬迁问题。
我们来进行复杂度分析下，假如一个单位为n的数组， 在最好的情况下，在数组尾部插入一个元素，只需要操作一次并且不涉及搬迁，所以最好的时间复杂度为 O(1) , 在最坏的情况下，在数组头部插入一个元素，需要搬迁元素N次，最坏的事件复杂度为 O(n), 那因为我们在每个位置插入元素的概率是一样的，所以平均情况时间复杂度为 (1+2+ …n)/n=O(n)

另外在一个特点的情况下，如果数组不需要保持原有元素的有序位置，我们可以将插入位置存放新元素，将以前的插入点旧元素放置数组尾部，例如前图面里面中，我们将数组变换为 A->B->X->D->E->F->C  ，这样的情况，时间复杂度可以将为 O(1)

我们再来看看 **删除操作**

跟插入数据类似，如果我们要删除第 k 个位置的数据，为了内存的连续性，也需要搬移数 据，不然中间就会出现空洞，内存就不连续了。

和插入类似，如果删除数组末尾的数据，则最好情况时间复杂度为 O(1)；如果删除开头的 数据，则最坏情况时间复杂度为 O(n)；平均情况时间复杂度也为 O(n)。

那么怎么样能够减少数组删除的次数和降低数组删除的时间复杂度呢？

**<font color=#FF0000 >我们可以采取类似JVM的机制来处理，先将需要删除的元素标记为删除状态，但并未实际的物理删除和搬移数据，等数组没有更多空间了，再进行一次性删除和搬移。</font>**

### 链表

链表是由一组节点组成的集合。每个节点包括两个部分：一个是存储数据元素的数据域，另一个是存储下一个结点地址的指针域。每个节点都使用一个对象的引用指向它的后继，最后一个节点的指针指向NULL。

链表不需要提前分配固定大小存储空间，当需要存储数据的时候分配一块内存并将这块内存插入链表中。

<img src="https://myvoice1.oss-cn-beijing.aliyuncs.com/github/sjjg/link-array.jpg" style="zoom:50%;" />

从图中我们看到，数组需要一块连续的内存空间来存储， 对内存的要求比较高。如果我们申请一个 100MB 大小的数组，当内存中没有连续的、足够 大的存储空间时，即便内存的剩余总可用空间大于 100MB，仍然会申请失败。而链表恰恰相反，它并不需要一块连续的内存空间，它通过“指针”将一组零散的内存块串 联起来使用，所以如果我们申请的是 100MB 大小的链表，根本不会有问题。

今天重点介绍三种最常见的链表结构，它们分别是：单链表、双 向链表和循环链表:

#### 单链表

单链表  [Linked List]：由各个内存结构通过一个 `Next` 指针链接在一起组成，每一个内存结构都存在后继内存结构【链尾除外】，内存结构由数据域和 Next 指针域组成。

![](https://myvoice1.oss-cn-beijing.aliyuncs.com/github/sjjg/dlb.png)

- Data 数据 + Next 指针，组成一个单链表的内存结构 ；
- 第一个内存结构称为 链头，最后一个内存结构称为 链尾；
- 链尾的 Next 指针设置为 NULL [指向空]；
- 单链表的遍历方向单一【只能从链头一直遍历到链尾】

下面一张图显示单链表得插入和删除操作：

![](https://myvoice1.oss-cn-beijing.aliyuncs.com/github/sjjg/dlb_op.jpg.png)

我们知道，在进行数组的插入、删除操作时，为了保持内存数据的连续性，需要做大量的数 据搬移，所以时间复杂度是 O(n)。而在链表中插入或者删除一个数据，我们并不需要为了 保持内存的连续性而搬移结点，因为链表的存储空间本身就不是连续的。所以，在链表中插 入和删除一个数据是非常快速的。所以对应的时间复杂度是 O(1)。

但是，有利就有弊。链表要想随机访问第 k 个元素，就没有数组那么高效了。你可以把链表想象成一个队伍，队伍中的每个人都只知道自己后面的人是谁，所以当我们希 望知道排在第 k 位的人是谁的时候，我们就需要从第一个人开始，一个一个地往下数。所 以，链表随机访问的性能没有数组好，需要 O(n) 的时间复杂度。

#### 双向链表

双向链表 [Double Linked List]：由各个内存结构通过指针 `Next` 和指针 `Prev` 链接在一起组成，每一个内存结构都存在前驱内存结构和后继内存结构【链头没有前驱，链尾没有后继】，内存结构由数据域、Prev 指针域和 Next 指针域组成。

![](https://myvoice1.oss-cn-beijing.aliyuncs.com/github/sjjg/dlink.png)

- Data 数据 + Next 指针 + Prev 指针，组成一个双向链表的内存结构；
- 第一个内存结构称为 链头，最后一个内存结构称为 链尾；
- 链头的 Prev 指针设置为 NULL， 链尾的 Next 指针设置为 NULL；
- Prev 指向的内存结构称为 前驱， Next 指向的内存结构称为 后继；
- 双向链表的遍历是双向的，即如果把从链头的 Next 一直到链尾的[NULL] 遍历方向定义为正向，那么从链尾的 Prev 一直到链头 [NULL ]遍历方向就是反向；

下面一张图显示双向链表得插入和删除操作：

![](https://myvoice1.oss-cn-beijing.aliyuncs.com/github/sjjg/insert_dlink.jpg)

![](https://myvoice1.oss-cn-beijing.aliyuncs.com/github/sjjg/delete_dlink.jpg)

1. 对于 **删除或者插入结点中“值等于某个给定值”的结点** 的情况下， ，不管是单链表还是双向链表，为了查找到值等于给定值的结点，都需要从 头结点开始一个一个依次遍历对比，直到找到值等于给定值的结点，然后再通过指针操作将其删除， 尽管单纯的删除操作时间复杂度是 O(1)，但遍历查找的时间是主要的耗时点，对应的时间 复杂度为 O(n)。
2. 对于 **删除或者插入给定指针指向的结点** 的情况下， 对于双向链表来说，这种情况就比较有优势了。因为双向链表中的结点已经保存了前驱 结点的指针，不需要像单链表那样遍历。所以，针对第二种情况，单链表删除操作需要 O(n) 的时间复杂度，而双向链表只需要在 O(1) 的时间复杂度内就搞定了！
3. 除了插入、删除操作有优势之外，对于一个有序链表，双向链表的按值查询的效率也要比单 链表高一些。因为，我们可以记录上次查找的位置 p，每次查询时，根据要查找的值与 p 的大小关系，决定是往前还是往后查找，所以平均只需要查找一半的数据。

#### 循环链表

单向循环链表 [Circular Linked List] : 由各个内存结构通过一个指针 `Next` 链接在一起组成，每一个内存结构都存在后继内存结构，内存结构由数据域和 Next 指针域组成。

双向循环链表 [Double Circular Linked List] : 由各个内存结构通过指针 `Next` 和指针 `Prev` 链接在一起组成，每一个内存结构都存在前驱内存结构和后继内存结构，内存结构由数据域、Prev 指针域和 Next 指针域组成。

![](https://myvoice1.oss-cn-beijing.aliyuncs.com/github/sjjg/dc_link.png)

- 循环链表分为单向、双向两种；
- 单向的实现就是在单链表的基础上，把链尾的 Next 指针直接指向链头，形成一个闭环；
- 双向的实现就是在双向链表的基础上，把链尾的 Next 指针指向链头，再把链头的 Prev 指针指向链尾，形成一个闭环；
- 循环链表没有链头和链尾的说法，因为是闭环的，所以每一个内存结构都可以充当链头和链尾；

循环链表其他操作跟单链表和双向链表基本一致，在此就不累赘了。

### 数组与链表比较

| 角度         |                             数组                             |                             链表                             |
| ------------ | :----------------------------------------------------------: | :----------------------------------------------------------: |
| 动态存储分配 | 数组必须事先定义固定的长度（元素个数），不能适应数据动态地增减的情况。当数据增加时，可能超出原定义的元素个数；当数据减少时，造成内存浪费。 | 链表动态地进行存储分配，可以适应数据动态地增减的情况，且可以方便地插入、删除数据项。（数组中插入、删除数据项时，需要移动其它数据项）。 |
| 逻辑结构角度 | 数组是将元素在内存中连续存放，由于每个元素占用内存相同，可以通过下标迅速访问数组中任何元素。但是如果要在数组中增加一个元素，需要移动大量元素，在内存中空出一个元素的空间，然后将要增加的元素放在其中。同理，如果想删除一个元素，同样需要移动大量元素去填掉被移动的元素。如果应用需要快速访问数据，很少或不插入和删除元素，就应该用数组。 | 链表中的元素在内存中不是顺序存储的，而是通过存在元素中的指针联系到一起。比如：上一个元素有个指针指到下一个元素，以此类推，直到最后一个元素。如果要访问链表中一个元素，需要从第一个元素开始，一直找到需要的元素位置。但是增加和删除一个元素对于链表数据结构就非常简单了，只要修改元素中的指针就可以了。如果应用需要经常插入和删除元素你就需要用链表数据结构了。 |
| 内存存储角度 |  (静态)数组从栈中分配空间, 对于程序员方便快速,但自由度小。   |       链表从堆中分配空间, 自由度大但申请管理比较麻烦。       |
| 总结         | 1）数组静态分配内存，链表动态分配内存；2）数组在内存中连续，链表不连续；3）数组元素在栈区，链表元素在堆区；4）数组利用下标定位，时间复杂度为O(1)，链表定位元素时间复杂度O(n)；5）数组插入或删除元素的时间复杂度O(n)，链表的时间复杂度O(1)。 |                                                              |

### 