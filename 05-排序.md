## 排序算法

### 总览

排序就是一系列数据，按照某个关键字（例如：销量，价格），进行递增或者递减的顺序排列起来。在平常的项目中，我们也经常会用到排序。排序非常 重要，常见经典排序方法有：冒泡排序、插入排序、选 择排序、归并排序、快速排序、计数排序、基数排序、桶排序等。

针对排序算法的空间复杂度，我们还引入了一个新的概念，原地排序（Sorted in place）。 原地排序算法，就是特指空间复杂度是 O(1) 的排序算法。

针对排序算法，我们还有一个 重要的度量指标，稳定性。这个概念是说，如果待排序的序列中存在值相等的元素，经过排 序之后，相等元素之间原有的先后顺序不变。

常见排序事件复杂度和稳定性对照表：

| 排序算法 |     平均时间     | 稳定性 |
| :------: | :--------------: | :----: |
| 希尔排序 | O(n<sup>2</sup>) |  稳定  |
| 冒泡排序 | O(n<sup>2</sup>) |  稳定  |
| 插入排序 | O(n<sup>2</sup>) |  稳定  |
| 选择排序 | O(n<sup>2</sup>) | 不稳定 |
| 快速排序 |     O(nlogn)     | 不稳定 |
| 归并排序 |     O(nlogn)     |  稳定  |
| 计数排序 |       O(N)       |  稳定  |
| 基数排序 |       O(N)       |  稳定  |
|  桶排序  |       O(N)       |  稳定  |

### 冒泡排序（Bubble Sort）

定义：冒泡排序只会操作相邻的两个数据。每次冒泡操作都会对相邻的两个元素进行比较，看是否 满足大小关系要求。如果不满足就让它俩互换。

我们举个例子：有一组 数据 9 6 7 5 8 2 1，需要进行冒泡排序，演示图如下：

![](https://myvoice1.oss-cn-beijing.aliyuncs.com/github/sjjg/maopao.jpg)

冒泡排序算法的原理比较容易理解，根据冒泡原理和上图所示给出核心代码：

```go
//冒泡排序算法
func bubbleSort(data []int) {
	arrLen := len(data)
	if arrLen <= 1 {
		return
	}
	for i := 0; i < arrLen; i++ {
		isChange := false //是否有数据交换
		for j := 0; j < arrLen-i-1; j++ {
			if data[j] > data[j+1] {
				data[j], data[j+1] = data[j+1], data[j]
				isChange = true
			}
		}
		//无数据交换 提交结束
		if isChange == false {
			break
		}
	}
}
```

根据上述规则可以得出：

- 冒泡的过程只涉及相邻数据的交换操作，只需要常量级的临时空间，所以它的空间复杂度为 O(1)，是一个原地排序算法。
- 在冒泡排序中，只有交换才可以改变两个元素的前后顺序。为了保证冒泡排序算法的稳定 性，当有相邻的两个元素大小相等的时候，我们不做交换，相同大小的数据在排序前后不会 改变顺序，所以冒泡排序是稳定的排序算法
- 次冒泡操作，最好情况时间复杂度是 O(n)， 以最坏情况时间复杂度为 O(n<sup>2</sup> ），平均时间复杂为：O(n<sup>2</sup>）

平均时间复杂度推导过程会用到概率论的定量分析，这样就使得平均时间复杂度推导难度大大最加，这边可以使用有序度方案解决，有序度方案来源于极客时间教程，满有序度= n*(n-1)/2，逆序度=满有序度–初始有序度； 初始有序度可以采取：n*(n-1)/4， 换句话说，平均情况下，需要 n*(n-1)/4 次交换操作，比较操作肯定要比交换操作多，而复 杂度的上限是 O(n<sup>2</sup>)，所以平均情况下的时间复杂度就是 O(n<sup>2</sup>)。

### 插入排序（Insertion Sort）

定义： 插入排序，一般也被称为直接插入排序。对于少量元素的排序，它是一个有效的算法 [1] 。插入排序是一种最简单的[排序]方法，它的基本思想是将一个记录插入到已经排好序的有序表中，从而一个新的、记录数增1的有序表。在其实现过程使用双层循环，外层循环对除了第一个元素之外的所有元素，内层循环对当前元素前面有序表进行待插入位置查找，并进行移动。

根据之前的操作方法一样，有一组 数据  9 6 5 8 2 1，需要进行插入排序，演示图如下：

![](https://myvoice1.oss-cn-beijing.aliyuncs.com/github/sjjg/zjpx.jpg)

插入排序算法的原理比较容易理解，根据插入原理和上图所示给出核心代码：

```go
//插入排序算法
func insertionSort(data []int) {
	len := len(data)
	if len <= 1 {
		return
	}
	for i := 1; i < len; i++ {
		value := data[i]
		j := i - 1
		for ; j >= 0; j-- {
			if data[j] > value {
				data[j+1] = data[j] //移动数据
			} else {
				break
			}
		}
		data[j+1] = value //插入数据
	}
}
```

根据上述规则可以得出：

- 在插入排序中，对于值相同的元素，我们可以选择将后面出现的元素，插入到前面出现元素 的后面，这样就可以保持原有的前后顺序不变，所以插入排序是稳定的排序算法。
- 如果要排序的数据已经是有序的，我们并不需要搬移任何数据。如果我们从尾到头在有序数 据组里面查找插入位置，每次只需要比较一个数据就能确定插入的位置。所以这种情况下， 最好是时间复杂度为 O(n)。注意，这里是从尾到头遍历已经有序的数据。
  如果数组是倒序的，每次插入都相当于在数组的第一个位置插入新的数据，所以需要移动大 量的数据，所以最坏情况时间复杂度为 O(n<sup>2</sup>)。
  还记得我们在数组中插入一个数据的平均时间复杂度是多少吗？没错，是 O(n)。所以，对 于插入排序来说，每次插入操作都相当于在数组中插入一个数据，循环执行 n 次插入操 作，所以平均时间复杂度为 O(n<sup>2</sup>)。
- 从实现过程可以很明显地看出，插入排序算法的运行并不需要额外的存储空间，所以空间复 杂度是 O(1)，也就是说，这是一个原地排序算法。

### 选择排序（Selection Sort）

定义：每一次从待排序的数据元素中选出最小（或最大）的一个元素，存放在序列的起始位置，直到全部待排序的数据元素排完。

有一组 数据  9 6 2 8，需要进行选择排序，演示图如下：

![](https://myvoice1.oss-cn-beijing.aliyuncs.com/github/sjjg/select_sort.jpg)

选择排序算法核心代码：

```go
func selectionDesSort(data []int) {
	len := len(data)
	if len <= 1 {
		return
	}
	minIdx := 0
	for i := 0; i < len; i++ {
		minIdx = i
		k := i + 1
		for ; k < len; k++ {
			if data[minIdx] > data[k] {
				minIdx = k
			}
		}
		if minIdx != i {
			data[i], data[minIdx] = data[minIdx], data[i]
		}
	}
}
```

根据上述规则可以得出：

- 选择排序是给每个位置选择当前元素最小的，比如给第一个位置选择最小的，在剩余元素里面给第二个元素选择第二小的，依次类推，直到第n-1个元素，第n个元素不用选择了，因为只剩下它一个最大的元素了。那么，在一趟选择，如果一个元素比当前元素小，而该小的元素又出现在一个和当前元素相等的元素后面，那么交换后稳定性就被破坏了。举个例子，序列5 8 5 2 9，我们知道第一遍选择第1个元素5会和2交换，那么原序列中两个5的相对前后顺序就被破坏了，所以选择排序是一个不稳定的排序算法。
- 选择排序算法的运行并不需要额外的存储空间,所以空间复杂度是 O(1),也就是说,这是一个原地排序算法
- 选择排序的交换操作介于 0 和 (n - 1)次之间。选择排序的比较操作为 n (n - 1） / 2 次之间。选择排序的赋值操作介于 0 和 3 (n - 1） 次之间。比较次数O(n<sup>2</sup>），比较次数与关键字的初始状态无关，总的比较次数N=(n-1）+(n-2）+...+1=n*(n-1）/2。交换次数O(n），最好情况是，已经有序，交换0次；最坏情况交换n-1次，逆序交换n/2次。交换次数比[冒泡排序]少多了，由于交换所需CPU时间比比较所需的CPU时间多，n值较小时，选择排序比冒泡排序快。

### 希尔排序(Shell's Sort)

定义：希尔排序，就是按某个增量值对数据进行分组，每组单独排序好后，再缩小这个增量，然后按新增量对数据分组后每个分组再各自排序。最终增加缩小到1的时候，排序结束。所以希尔排序又叫缩小增量排序(Diminishing Increment Sort)，也是对直接插入排序算法的优化。

有一组 数据  [81 87 47 59 81 18 25 40 56 0 94] ，希尔排序顺序，演示图如下：

![](https://myvoice1.oss-cn-beijing.aliyuncs.com/github/sjjg/shellsort.jpg)

希尔核心算法：

```go
/** 希尔排序实现*/
func shell_sort(data []int) {
	len := len(data)
	if len <= 1 {
		return
	}
	h := int(len / 3) + 1
	for h >= 1 {
		for i := h; i < len; i++ {
			for j := i; j >= h && data[j] < data[j-h]; j -= h {
				swap(data, j, j-h)
			}
		}
		h = int(h / 3)
	}
}

func swap(data []int, i, j int) {
	data[i], data[j] = data[j], data[i]
}
```

根据上述过程可以得出：

- 希尔排序是一个不稳定的排序算法。
- 平均时间复杂度未知，需要跟据具体的n分层来决定。最坏时间复杂度为O(n<sup>2</sup>)
- 希尔排序是一个原地排序算法。

### 归并排序（Merge Sort）



### 快速排序（Quicksort）

### 桶排序（Bucket sort）

### 基数排序（Radix sort）