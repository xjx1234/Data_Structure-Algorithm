## 栈和队列

### 栈

#### 栈的概念

栈是一种运算**受限的线性表**，其限制是指只仅允许在表的一端进行插入和删除操作，这一端被称为栈顶（Top），相对地，把另一端称为栈底（Bottom）。把新元素放到栈顶元素的上面，使之成为新的栈顶元素称作进栈、入栈或压栈（Push）；把栈顶元素删除，使其相邻的元素成为新的栈顶元素称作出栈或退栈（Pop）。这种受限的运算使栈拥有“***\*先进后出”\****的特性（First In Last Out），简称 **FILO**。

![](https://myvoice1.oss-cn-beijing.aliyuncs.com/github/sjjg/stack.jpg)

栈的基本运算有六种：

- 构造空栈：InitStack(S)
- 判栈空: StackEmpty(S)
- 判栈满： StackFull(S)
- 进栈： Push(S,x)、可形象地理解为压入，这时栈中会多一个元素
- 退栈： Pop(S) 、 可形象地理解为弹出，弹出后栈中就无此元素了。
- 取栈顶元素：StackTop(S),不同与弹出，只是使用栈顶元素的值，该元素仍在栈顶不会改变。

栈的分类按实现方式来分为两种：

- 用数组实现的栈，我们叫作 **顺序栈** （实现参考 code/golang/stack/arrayStack.go）
- 用链表实现的栈，我们叫作 **链式栈** （实现参考 code/golang/stack/linkedListStack.go）

复杂度分析：

不管是顺序栈还是链式栈，我们存储数据只需要一个大小为 n 的数组就够了。在入栈和出 栈过程中，只需要一两个临时变量存储空间，所以空间复杂度是 O(1)

不管是顺序栈还是链式栈，入栈、出栈 只涉及栈顶个别数据的操作，所以时间复杂度都是 O(1)

#### 支持动态扩容的顺序栈

顺序栈是基于数组实现的，数组是一个初始化固定大小的内存空间的结构，这时候如何来实现一个支持动态扩容的数组的呢？当数组空间不够时，我们就重新申请一块更大的内存，将原来数组中数据统统拷贝过去。这样就实现了一 个支持动态扩容的数组。

所以，如果要实现一个支持动态扩容的栈，我们只需要底层依赖一个支持动态扩容的数组就可以了。当栈满了之后，我们就申请一个更大的数组，将原来的数据搬移到新数组中。如图，可以对照着理解一下。

<img src="https://myvoice1.oss-cn-beijing.aliyuncs.com/github/sjjg/auto_array_stack.png" style="zoom: 67%;" />

基于复杂度分析，动态扩容顺序栈的操作 空间复杂度是 O(1)， 时间复杂度也为  O(1) 。

#### 栈的应用

这边列举几个栈在实际应用中的例子：

1.  函数调用栈

   操作系统给每个线程分配了一块独立的内存空间，这块内存被组织成“栈”这种 结构, 用来存储函数调用时的临时变量。每进入一个函数，就会将临时变量作为一个栈帧入 栈，当被调用函数执行完成，返回之后，将这个函数对应的栈帧出栈。为了让你更好地理 解，我们一块来看下这段代码的执行过程。

   ```c
   int main() {
       int a = 1;
       int ret = 0;
       int res = 0;
       ret = add(3, 5);
       res = a + ret;
       printf("%d", res);
       reuturn 0; 
   }
    
   int add(int x, int y) {
       int sum = 0;
       sum = x + y;
       return sum;
   }
   ```

   从代码中我们可以看出，main() 函数调用了 add() 函数，获取计算结果，并且与临时变量 a 相加，后打印 res 的值。为了让你清晰地看到这个过程对应的函数栈里出栈、入栈的操作，如图。图中显示的是，在执行到 add() 函数时，函数调用栈的情况。

   <img src="https://myvoice1.oss-cn-beijing.aliyuncs.com/github/sjjg/func_stack.png" style="zoom: 67%;" />

2. 表达式求值应用

   我们再来看栈的另一个常见的应用场景，编译器如何利用栈来实现表达式求值。
   为了方便解释，我将算术表达式简化为只包含加减乘除四则运算，比如：34+13*9+4412/3。对于这个四则运算，我们人脑可以很快求解出答案，但是对于计算机来说，理解这 个表达式本身就是个挺难的事儿。如果换作你，让你来实现这样一个表达式求值的功能，你 会怎么做呢？
   实际上，编译器就是通过两个栈来实现的。其中一个保存操作数的栈，另一个是保存运算符 的栈。我们从左向右遍历表达式，当遇到数字，我们就直接压入操作数栈；当遇到运算符， 就与运算符栈的栈顶元素进行比较。
   如果比运算符栈顶元素的优先级高，就将当前运算符压入栈；如果比运算符栈顶元素的优先 级低或者相同，从运算符栈中取栈顶运算符，从操作数栈的栈顶取 2 个操作数，然后进行 计算，再把计算完的结果压入操作数栈，继续比较。
   我将 3+5*8-6 这个表达式的计算过程画成了一张图，你可以结合图来理解我刚讲的计算过 程。

   <img src="https://myvoice1.oss-cn-beijing.aliyuncs.com/github/sjjg/jsq_stack.png" style="zoom:67%;" />

3. 括号匹配

   除了用栈来实现表达式求值，我们还可以借助栈来检查表达式中的括号是否匹配。
   我们同样简化一下背景。我们假设表达式中只包含三种括号，圆括号 ()、方括号 [] 和花括 号{}，并且它们可以任意嵌套。比如，{[{}]}或 [{()}([])] 等都为合法格式，而{[}()] 或 [({)] 为 不合法的格式。那我现在给你一个包含三种括号的表达式字符串，如何检查它是否合法呢？
   这里也可以用栈来解决。我们用栈来保存未匹配的左括号，从左到右依次扫描字符串。当扫 描到左括号时，则将其压入栈中；当扫描到右括号时，从栈顶取出一个左括号。如果能够匹 配，比如“(”跟“)”匹配，“[”跟“]”匹配，“{”跟“}”匹配，则继续扫描剩下的字 符串。如果扫描的过程中，遇到不能配对的右括号，或者栈中没有数据，则说明为非法格 式。
   当所有的括号都扫描完成之后，如果栈为空，则说明字符串为合法格式；否则，说明有未匹 配的左括号，为非法格式。

### 队列

#### 队列概念

像栈一样，队列也是一种**受限的线性表**。与栈结构不同的是，队列的两端都"开口"，要求数据只能从一端进，从另一端出。且遵循 **FIFO "先进先出"** 原则的线性存储结构。通常，称进数据的一端为 "队尾"，出数据的一端为 "队头"，数据元素进队列的过程称为 "入队"，出队列的过程称为 "出队"。

> 栈和队列不要混淆，栈结构是一端封口，特点是"先进后出"；而队列的两端全是开口，特点是"先进先出"。

<img src="https://timgsa.baidu.com/timg?image&amp;quality=80&amp;size=b9999_10000&amp;sec=1598532912096&amp;di=a646a20680ccc3f249a5353919b409a7&amp;imgtype=0&amp;src=http%3A%2F%2Fwww.west.cn%2Finfo%2Fupload%2F20181204%2Fzcv1rqc32of.png" alt="img" style="zoom:67%;" />

队列的分类按实现方式来分为两种：

- 用数组实现的栈，我们叫作 **顺序队列  **（代码实现参考 code/golang/queue/arrayQueue.go）
- 用链表实现的栈，我们叫作 **链式队列** （代码实现参考 code/golang/queue/linkedListQueue.go）