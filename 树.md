## 树

### 树（ Tree）的概念

数据结构中常用得结构类型包括线性结构与非线性结构，线性结构包括 : 数组，栈，队列，串，链表等；非线性结构包括：树，图等。那么什么叫做树呢？

百度中给出得数得定义为：树是一种数据结构，它是由n（n>=1）个有限节点组成一个具有层次关系的集合。把它叫做“树”是因为它看起来像一棵倒挂的树，也就是说它是根朝上，而叶朝下的。

树具有以下特点：

1. 每个节点有零个或多个子节点；
2. 没有父节点的节点称为根节点；
3. 每一个非根节点有且只有一个父节点；
4. 除了根节点外，每个子节点可以分为多个不相交的子树；

树结构如下图所示：

![](https://my-data-structure.oss-cn-shanghai.aliyuncs.com/tree/tree-01.png)

综合上图树的结构以及树的特点，我们可以得出

- 元素 A B C D E F G H I 都为树的 **节点**；
- 节点A 是 节点B的 **父节点**，节点B则是A的 **子节点**；
- 节点 A 没有父节点，则A是该树的 **根节点**；
- 节点E F G H I没有子节点，则可以被称为树的 **叶子节点 **或 **叶节点** ;
- 节点 B C D 拥有同一个父节点 A， 则 B C D 互为 **兄弟节点**；

除了上述概念以外，关于树 还有 **高度**， **深度**， **层** 几个概念，这几个概念比较容易混淆，描述起来比较空洞，我们根据下图所示，进行归纳总结：



![](https://my-data-structure.oss-cn-shanghai.aliyuncs.com/tree/tree-02.png)



- 节点高度 =  节点到叶子节点的最长路径(边数)
- 节点深度 =  根节点到这个节点所经历的边数
- 节点层数 =  节点深度 + 1

### 二叉树 （Binary Tree）

#### 二叉树概念

树的结构多种多样，但二叉树是最常用的树结构。

二叉树从表意理解为： 每个节点最多有2个子节点，分别为左子节点和右子节点，但二叉树并不强制每个节点都必须有2个子节点，有的节点可以只有左节点，也可以只有右节点。

百度给出的二叉树的定义为：二叉树（binary tree）是指树中节点的度不大于2的有序树，它是一种最简单且最重要的树。二叉树的递归定义为：二叉树是一棵空树，或者是一棵由一个根节点和两棵互不相交的，分别称作根的左子树和右子树组成的非空树；左子树和右子树又同样都是二叉树  。

二叉树特点：

- 每个结点最多有两颗子树，所以二叉树中不存在度大于2的结点；
- 左子树和右子树是有顺序的，次序不能任意颠倒；
- 即使树中某结点只有一棵子树，也要区分它是左子树还是右子树；

二叉树性质：

- 在二叉树的第i层上最多有2<sup>i-1</sup> 个节点（i>=1）；

- 二叉树中如果深度为k,那么最多有2<sup>k</sup> -1个节点(k>=1）；

- n<sub>0</sub>=n<sub>2</sub>+1 n<sub>0</sub>表示度数为0的节点数，n<sub>2</sub>表示度数为2的节点数；

- 在完全二叉树中，具有n个节点的完全二叉树的深度为[log<sub>2</sub>n]+1，其中[log<sub>2</sub>n]是向下取整；

- 若对含 n 个结点的完全二叉树从上到下且从左至右进行 1 至 n 的编号，则对完全二叉树中任意一个编号为 i 的结点有如下特性：

  > (1) 若 i=1，则该结点是二叉树的根，无双亲, 否则，编号为 [i/2] 的结点为其双亲结点;
  >
  > (2) 若 2i>n，则该结点无左孩子， 否则，编号为 2i 的结点为其左孩子结点；
  >
  > (3) 若 2i+1>n，则该结点无右孩子结点， 否则，编号为2i+1 的结点为其右孩子结点。

下图展示了几种二叉树的形态：

![](https://my-data-structure.oss-cn-shanghai.aliyuncs.com/tree/tree-03.png)

**满二叉树**：在一棵二叉树中。如果所有分支结点都存在左子树和右子树，并且所有叶子都在同一层上，这样的二叉树称为满二叉树。如上图1所示。

**完全二叉树**：通俗的解释为对一颗具有n个结点的二叉树按层编号，如果编号为i(1<=i<=n)的结点与同样深度的满二叉树中编号为i的结点在二叉树中位置完全相同，则这棵二叉树称为完全二叉树。如果需要好理解点，则可以理解为二叉树中除去最后一层节点为满二叉树，且最后一层的结点依次从左到右分布，则此二叉树被称为完全二叉树。如上图2所示。

#### 二叉树存储

二叉树的存储结构有两种，分别为顺序存储和链式存储。

##### 顺序存储

二叉树的顺序存储结构就是使用一维数组存储二叉树中的结点，并且结点的存储位置，就是数组的下标索引。

![](https://my-data-structure.oss-cn-shanghai.aliyuncs.com/tree/tree-04.png)

上图中黄色阴影表示存在的节点，粉红色阴影节点表示不存在的节点。

如上图树1与树2，采用顺序存储方式，（粉红×代表空缺）则表示为：

![](https://my-data-structure.oss-cn-shanghai.aliyuncs.com/tree/tree-05.png)

从上面顺序存储的数据可以看出，树1是一颗完全二叉树，顺序存储可以比较完美的将整颗树串联起来，但树2在顺序存储结构中已经出现了空间浪费的情况，如果出现极端的右斜树极端情况，采用顺序存储的方式是十分浪费空间的。

##### 链式存储

通过学习你会发现，其实二叉树并不适合用数组顺序存储，因为并不是每个二叉树都是完全二叉树，普通二叉树使用顺序数组存储或多或多会存在空间浪费的现象，既然顺序存储不能满足二叉树的存储需求，那么考虑采用链式存储。

链式存储的表现形式如下图：

![](https://my-data-structure.oss-cn-shanghai.aliyuncs.com/tree/tree-06.png)



由上图结构以及二叉树定义可知，二叉树的每个结点最多有两个孩子。因此，可以将结点数据结构定义为**一个数据**和**两个指针**，两个指针分别为左右指针，将整颗树串联起来。节点定义代码可以为:

```go
type BiTNode struct {
	Value       int
	Left, Right *BiTNode
}
```

#### 二叉树遍历

二叉树的遍历是指从二叉树的根结点出发，按照某种次序依次访问二叉树中的所有结点，使得每个结点被访问一次，且仅被访问一次。

先给出演示图，下面遍历的说明将用此图作为演示例子：

![](https://my-data-structure.oss-cn-shanghai.aliyuncs.com/tree/tree-07.png)

二叉树的遍历主要方式：

- 前序遍历 :  按照通俗的来讲是对于树中的任意节点来说，先打印这个节点，然后再打印它的左子树，最后打印它的右子树。按着前序遍历规则上图的依次顺序为： **A->B->D->H->E->C->F->I->J->G**，前序实现代码：

  ```go
  func (nodes *BiTNode) PreOrderTraverse() []int {
  	result := []int{}
  	if nodes != nil {
  		result = append(result, nodes.Value)
  		result = append(result, nodes.Left.PreOrderTraverse()...)
  		result = append(result, nodes.Right.PreOrderTraverse()...)
  	}
  	return result
  }
  ```

  

- 中序遍历 :  按照通俗的来讲是对于树中的任意节点来说，先打印它的左子树，然后再打印它本身，最后打印它的右子树。按着中序遍历规则上图的依次顺序为： **H->D->B->E->A->I->F->J->C->G**，实现代码：

  ```go
  func (nodes *BiTNode) InOrderTraverse() []int {
  	result := []int{}
  	if nodes != nil {
  		result = append(result, nodes.Left.InOrderTraverse()...)
  		result = append(result, nodes.Value)
  		result = append(result, nodes.Right.InOrderTraverse()...)
  	}
  	return result
  }
  ```

  

- 后序遍历 :  按照通俗的来讲是对于树中的任意节点来说，先打印它的左子树，然后再打印它的右子树， 最后打印这个节点本身。按着后序遍历规则上图的依次顺序为：**H->D->E->B->I->J->F->G->C->A**，实现代码：

  ```go
  func (nodes *BiTNode) PostOrderTraverse() []int {
  	result := []int{}
  	if nodes != nil {
  		result = append(result, nodes.Left.PostOrderTraverse()...)
  		result = append(result, nodes.Right.PostOrderTraverse()...)
  		result = append(result, nodes.Value)
  	}
  	return result
  }
  ```

  

- 层级遍历 :  按照树的层次自上而下的遍历二叉树。按着层级遍历规则上图的依次顺序为：**A->B->C->D->E->F->G->H->I->J**，实现代码：

  ```go
  func (nodes *BiTNode) LevelOrder() []int {
  	var stack []*BiTNode
  	result := []int{}
  	stack = append(stack, nodes)
  	for j := 0; j < len(stack); j++ {
  		node := stack[j]
  		result = append(result, node.Value)
  		if node.Left != nil {
  			stack = append(stack, node.Left)
  		}
  		if node.Right != nil {
  			stack = append(stack, node.Right)
  		}
  	}
  	return result
  }
  ```

二叉树更多的操作，参考代码`binary-tree.go`

#### 二叉查找树 （Binary Search Tree）

二叉查找树(BST)是二叉树中常用的一种类型，也叫二叉搜索树。顾名思义，二叉查找树是为了 实现快速查找而生的。不过，它不仅仅支持快速查找一个数据，还支持快速插入、删除一个 数据。

二叉查找树对于任意一个节点必须满足下列特点：

- 若其左子树存在，则其左子树中每个节点的值都不大于该节点值
- 若其右子树存在，则其右子树中每个节点的值都不小于该节点值

二叉查找树如图：

![](https://my-data-structure.oss-cn-shanghai.aliyuncs.com/tree/tree-08.png)

下面我们对二叉查找树的查找，删除，新增节点操作进行实现：

##### 查找节点

二叉查找树查找一个节点的逻辑如下：

- 首先查找根节点，如果根节点是我们需要查找的数据，则返回
- 如果查找的节点数值比根节点数据要小，则递归遍历左子树数据，直接查找相关节点返回
- 如果查找的节点数值比根节点数据要大，则递归遍历右子树数据，查找到相关节点后返回

如下图，查找节点值为21的路线，先从根节点比较(21<33)，遍历左子树(21>18)，对比右节点(21<23)，继续对比左节点(21=21), 找到节点。

![](https://my-data-structure.oss-cn-shanghai.aliyuncs.com/tree/tree-0901.png)

代码实现如下：

```go
func (root *TreeNode) searchBST(val int) *TreeNode {
	if root == nil {
		return nil
	}
	if root.Val == val {
		return root
	}
	node := &TreeNode{}
	if root.Val > val {
		node = root.Left.searchBST(val)
	} else {
		node = root.Right.searchBST(val)
	}
	return node
}
```

BST 算法查找时间依赖于树的拓扑结构。最佳情况是 O(log­2n)，而最坏情况是 O(n)。

##### 增加节点

当向树中插入一个新的节点时，该节点将总是作为叶子节点。所以最困难的地方就是如何找到该节点的父节点。其实找父节点的解决就是BST查询节点的解决办法，跟节点查询差不多，相对来说，还是比较简单的。

代码实现：

```go
func (root *TreeNode) insertIntoBST(val int) *TreeNode {
	if root == nil {
		return &TreeNode{val, nil, nil}
	}
	if root.Val > val {
		if root.Left == nil {
			root.Left = &TreeNode{val, nil, nil}
		} else {
			root.Left = root.Left.insertIntoBST(val)
		}
	} else {
		if root.Right == nil {
			root.Right = &TreeNode{val, nil, nil}
		} else {
			root.Right = root.Right.insertIntoBST(val)
		}
	}
	return root
}
```

BST 插入时间依赖于树的拓扑结构。最佳情况是 O(log­2n)，而最坏情况是 O(n)。

##### 删除节点

二叉查找树的查找、插入操作都比较简单易懂，但是它的删除操作就比较复杂了 。本质上是查找前驱或者后续节点来替代。二叉查找树删除可以分为以下几种类型：

- 如果删除的节点是叶子节点，则直接删除该节点
- 如果删除的节点只有一个子节点，则用子节点来替代
- 如果删除的节点有2个子节点，则需要找到相关的前驱节点或者后继替代节点

前驱节点： 小于当前节点的最大值

后继节点： 大于当前节点的最小值

代码实现：

```go
func (root *TreeNode) deleteNode(key int) *TreeNode {
	if root == nil {
		return nil
	}
	if root.Val > key {
		root.Left = root.Left.deleteNode(key)
	} else if root.Val < key {
		root.Right = root.Right.deleteNode(key)
	} else {
		if root.Left == nil {
			return root.Right
		} else if root.Right == nil {
			return root.Left
		} else {
			nextNode := root.Left
			for nextNode.Right != nil {
				nextNode = nextNode.Right
			}
			nextNode.Right = root.Right
			return root.Right
		}
	}
	return root
}
```

和查找、插入算法类似，删除算法的运行时间也与 BST 的拓扑结构有关，最佳情况是 O(log­2n)，而最坏情况是 O(n)。

`二叉查找树更多的操作，参考代码 binary-search-tree.go`

#### 平衡二叉查找树（AVL Tree）

平衡二叉查找树也叫自平衡二叉搜索树（Self-Balancing Binary Search Tree），所以其本质也是一颗二叉搜索树，不过为了限制左右子树的高度差，避免出现倾斜树等偏向于线性结构演化的情况，所以对二叉搜索树中每个节点的左右子树作了限制，左右子树的高度差称之为平衡因子，平衡二叉树必须具备以下特点：

1. 左右子树必须是AVL数
2. 左右子树平衡因子不能大于1 

平衡二叉查找树中“平衡”的意思，其实就是让整棵树左右看起来比较“对称”、比 较“平衡”，不要出现左子树很高、右子树很矮的情况。这样就能让整棵树的高度相对来说 低一些，相应的插入、删除、查找等操作的效率高一些。

AVL树的出现就是为了解决平衡性问题，它的核心内容就是平衡处理机制，即所谓的旋转，一共有四种形式的旋转：右单旋、左单旋、左右双旋和右左双旋。



**左单旋**：当插入的结点为失衡点的**右子树**的**右子树**中（左右孩子都行），即为RR模式的情况下，可以使用左旋转。如下图就是左单旋演示：



<img src="https://my-data-structure.oss-cn-shanghai.aliyuncs.com/tree/tree-1001.png" style="zoom:80%;" />

如上图，A失衡节点为15， B失衡节点为10； 经给左旋后：

- 原失衡节点得右节点变成该失衡节点得父节点。A的失衡节点（15）的右节点(20)成为失衡节点(15)的父节点；B的失衡节点（10）的右节点(15)成为失衡节点(10)的父节点；
- 原失衡节点右节点的左节点变成失衡节点右节点。A的失衡节点（15）的右节点(20)的左节点（空节点）成为失衡节点（15）的右节点；A的失衡节点（10）的右节点(15)的左节点（13）成为失衡节点（10）的右节点；
- 原失衡节点变成新父节点的左节点。A的失衡节点（15）成为新父节点(20)的左节点；B的失衡节点（10）成为新父节点(15)的左节点

代码表现为：

```go
func (t *AVLNode) leftRotate() *AVLNode {
	rootNode := t.Right
	t.Right = rootNode.Left
	rootNode.Left = t
	t.Height = max(t.Left.getHeight(), t.Right.getHeight()) + 1
	rootNode.Height = max(rootNode.Left.getHeight(), rootNode.Right.getHeight()) + 1
	return rootNode
}
```



**右单旋：**当插入的结点为**失衡点的左子树**的**左子树**中，即为LL模式，可以使用右旋，演示图如下：

![](https://my-data-structure.oss-cn-shanghai.aliyuncs.com/tree/tree-11.png)



如上图，A失衡节点为80， B失衡节点为100； 经给右旋后：

- 原失衡点左节点变为失衡点的父节点；A失衡节点(80)左节点(70)成为失衡点的父节点；B失衡点(100)左节点(80)成为失衡点的父节点；
- 原失衡点左节点的右节点成为失衡节点的左节点；A失衡节点(80)的右节点(空节点)成为失衡点左节点；B失衡点(100)的右节点(90)成为失衡点的左节点；
- 原失衡节点成为新父节点的右节点；A失衡点(80)成为新父节点(70)的右节点；B失衡点(100)成为新父节点(80)的右节点

代码实现为：

```go
func (t *AVLNode) rightRotate() *AVLNode {
	rootNode := t.Left
	t.Left = rootNode.Right
	rootNode.Right = t
	t.Height = max(t.Left.getHeight(), t.Right.getHeight()) + 1
	rootNode.Height = max(rootNode.Left.getHeight(), rootNode.Right.getHeight()) + 1
	return rootNode
}
```



**先左旋，再右旋**：当插入的结点为失衡点的**左子树的右子树**中（左右孩子都行）；即为LR模式，如图：

![](https://my-data-structure.oss-cn-shanghai.aliyuncs.com/tree/tree-12.png)

此处的先左旋，是先围绕失衡点左节点进行左旋，然后再按新树的新失衡点进行右旋。左旋以及右旋规则跟前面所描述一致。

代码实现：

```go
func (t *AVLNode) LeftThenRightRotate() *AVLNode {
	sonRootNode := t.Left.leftRotate()
	t.Left = sonRootNode
	return t.rightRotate()
}

```



**先右旋，再左旋**：当插入的结点在失衡点的**右子树的左子树**中（左右孩子都行），即RL模式，演示如图：

此处的先右旋，是先围绕失衡点右节点进行右旋，然后再按新树的新失衡点进行左旋。左旋以及右旋规则跟前面所描述一致。

![](https://my-data-structure.oss-cn-shanghai.aliyuncs.com/tree/tree-13.png)

代码实现：

```go
func (t *AVLNode) rightThenLeftRotate() *AVLNode {
	sonRootNode := t.Right.rightRotate()
	t.Right = sonRootNode
	return t.leftRotate()
}
```



#### 红黑树