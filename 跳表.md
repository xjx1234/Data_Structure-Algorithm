## 跳表

### 跳表概念

跳表全称为跳跃列表，它允许快速查询，插入和删除一个有序连续元素的数据链表。跳跃列表的平均查找和插入时间复杂度都是O(logn)。快速查询是通过维护一个多层次的链表，且每一层链表中的元素是前一层链表元素的子集（见下边的示意图）。一开始时，算法在最稀疏的层次进行搜索，直至需要查找的元素在该层两个相邻的元素中间。这时，算法将跳转到下一个层次，重复刚才的搜索，直到找到需要查找的元素为止。

我们知道二叉搜索算法能够高效的查询数据，但是需要一块连续的内存，而且增删改效率很低。跳表，是基于链表实现的一种类似“二分”的算法。它可以快速的实现增，删，改，查操作。

![img](https://pic2.zhimg.com/80/v2-406ac352da4f3c45da01ba5e2c168d9d_720w.jpg)

一个跳表，应该具有以下特征：

1. 一个跳表应该有几个层（level）组成；
2. 跳表的第一层包含所有的元素；
3. 每一层都是一个有序的链表；
4. 如果元素x出现在第i层，则所有比i小的层都包含x；
5. 第i层的元素通过一个down指针指向下一层拥有相同值的元素；
6. 在每一层中，-1和1两个元素都出现(分别表示INT_MIN和INT_MAX)；
7. Top指针指向最高层的第一个元素。

### 查找

 在跳跃表中查找一个元素x，按照如下几个步骤进行：

   1. 从最上层的链（Sh）的开头开始

2. 假设当前位置为p，它向右指向的节点为q（p与q不一定相邻），且q的值为y。将y与x作比较
        (1) x=y 输出查询成功及相关信息
        (2) x>y 从p向右移动到q的位置
        (3) x<y 从p向下移动一格

3. 如果当前位置在最底层的链中（S0），且还要往下移动的话，则输出查询失败

![img](http://www.cppblog.com/images/cppblog_com/mysileng/QQ%E6%88%AA%E5%9B%BE20130406201943.jpg)

### 插入

 首先明确，向跳跃表中插入一个元素，相当于在表中插入一列从S0中某一位置出发向上的连续一段元素。有两个参数需要确定，即插入列的位置以及它的“高度”。
 关于插入的位置，我们先利用跳跃表的查找功能，找到比x小的最大的数y。根据跳跃表中所有链均是递增序列的原则，x必然就插在y的后面。
而插入列的“高度”较前者来说显得更加重要，也更加难以确定。由于它的不确定性，使得不同的决策可能会导致截然不同的算法效率。为了使插入数据之后，保持该数据结构进行各种操作均为O(logn)复杂度的性质，我们引入随机化算法（Randomized Algorithms）。

我们定义一个随机决策模块，它的大致内容如下：

产生一个0到1的随机数r   r ← random() 

如果r小于一个常数p，则执行方案A， if r<p then do A 

否则，执行方案B     else do B 

初始时列高为1。插入元素时，不停地执行随机决策模块。如果要求执行的是A操作，则将列的高度加1，并且继续反复执行随机决策模块。直到第i次，模块要求执行的是B操作，我们结束决策，并向跳跃表中插入一个高度为i的列。

 我们来看一个例子：
 假设当前我们要插入元素“40”，且在执行了随机决策模块后得到高度为4
 步骤一：找到表中比40小的最大的数，确定插入位置

![img](http://www.cppblog.com/images/cppblog_com/mysileng/QQ%E6%88%AA%E5%9B%BE20130406202023.jpg)

步骤二：插入高度为4的列，并维护跳跃表的结构

![img](http://www.cppblog.com/images/cppblog_com/mysileng/QQ%E6%88%AA%E5%9B%BE20130406202042.jpg)

### 删除

删除操作分为以下三个步骤：

- 在跳跃表中查找到这个元素的位置，如果未找到，则退出 
- 将该元素所在整列从表中删除 
- 将多余的“空链”删除 

![img](http://www.cppblog.com/images/cppblog_com/mysileng/QQ%E6%88%AA%E5%9B%BE20130406202134.jpg)

### 时间复杂度分析

既然跳表可以提升链表查找元素的效率，那查找一个元素的时间复杂度到底是多少呢？查找元素的过程是从最高级索引开始，一层一层遍历最后下沉到原始链表。所以，时间复杂度 = 索引的高度 * 每层索引遍历元素的个数。

先来求跳表的索引高度。如下图所示，假设每两个结点会抽出一个结点作为上一级索引的结点，原始的链表有n个元素，则一级索引有n/2 个元素、二级索引有 n/4 个元素、k级索引就有 n/2k个元素。最高级索引一般有2个元素，即：最高级索引 h 满足 2 = n/2h，即 h = log2n - 1，最高级索引 h 为索引层的高度加上原始数据一层，跳表的总高度 h = log2n。

<img src="https://user-gold-cdn.xitu.io/2019/9/30/16d7dfcf5454a0ef?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="æ¥æ¾çæ¶é´å¤æåº¦è¯æ.jpeg" style="zoom:50%;" />

我们看上图中加粗的箭头，表示查找元素 x 的路径，那查找过程中每一层索引最多遍历几个元素呢？

图中所示，现在到达第 k 级索引，我们发现要查找的元素 x 比 y 大比 z 小，所以，我们需要从 y 处下降到 k-1 级索引继续查找，k-1级索引中比 y 大比 z 小的只有一个 w，所以在 k-1 级索引中，我们遍历的元素最多就是 y、w、z，发现 x 比 w大比 z 小之后，再下降到 k-2 级索引。所以，k-2 级索引最多遍历的元素为 w、u、z。其实每级索引都是类似的道理，每级索引中都是两个结点抽出一个结点作为上一级索引的结点。 现在我们得出结论：当每级索引都是两个结点抽出一个结点作为上一级索引的结点时，每一层最多遍历3个结点。

跳表的索引高度 h = log2n，且每层索引最多遍历 3 个元素。所以跳表中查找一个元素的时间复杂度为 O(3*logn)，省略常数即：O(logn)。

