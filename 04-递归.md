## 递归算法

### 递归概述

简单的说，**递归**指一个函数直接或者间接调用自己。

递归是一种数学上分而自治的思想。

- 将原问题分解为规模较小的问题进行处理，分解后的问题与原问题类型完全相同，当规模较小。通过小规模问题的解，能够轻易求得原生问题的解。
- 问题的分解时有限的，当边界条件不能满足时，分解问题（继续递归），当边界条件满足时，直接求解（递归结束）。

使用递归必须满足三个条件：

1.  递归必须有一个明确的终止条件
2.  该函数所处理的数据规模递减, 求解思路完全一样
3.   一个问题的解可以分解为几个子问题的解

递归模型的一般表示法：


$$
f(n) =\left\{
\begin{matrix}
 a{_n}  \ \ \bigcup  \ \ f(n-1) \ \ \ n>1
 \\   \\
 a1 
\end{matrix}
\right.
$$

### 应用的递归解决方案

- 求和递归的实现

  **题：** `SUM(n) = 1 + 2 + 3 + ... + n` 

  **解：**

  首先按着递归模型以及递归三要素来分析题目，求和递归的明确终止条件为 `n == 1` ; 求和的递归相同解决思路是： `n + SUM(n-1)` ；也符合可以分解几个子问题解决。求和的递归模型为：
  $$
  SUM(n) =\left\{
  \begin{matrix}
   n  \ \ +  \ \ SUM(n-1) \ \ \ n>1
   \\   \\
   1   \ \ \ \ n == 1
  \end{matrix}
  \right.
  $$
  核心 SUM(n) 的 代码实现 （完整实现-参考 code\golang\递归\sum.go）：

  ```go
  func sum(n int) int {
  	s := 0
  	if n == 1 {
  		s = s + n
  	} else if n > 1 {
  		s = n + sum(n-1)
  	}
  	return s
  }
  ```

  

- 斐波那契数列的实现

  **题：** 写一个函数，输入 `n` ，求斐波那契（Fibonacci）数列的第 `n` 项。斐波那契数列的数据结构如下：

  > 1，1，2，3，5，8，13，21，34， ......

  **解：** 

  满足 `n == 2 || n ==1`  时候终止条件 ;   满足问题的解可以分解为几个子问题的解；满足  `fac(n-1) + f(n-2) = fac(n)` 的求解思路完全一样的要素。

  模型为：
  $$
  fac(n) =\left\{
  \begin{matrix}
   fac(n-1) \ \ +  \ \ fac(n-2) \ \ \ n>=3
   \\   \\
   1   \ \ \ \ n == 2
   \\   \\
   1   \ \ \ \ n == 1
  \end{matrix}
  \right.
  $$
  核心函数 fac(n) 代码实现 （完整实现-参考 code\golang\递归\fac.go）：

  ```go
  func fac(n int) int {
  	var ret int
  	if n > 2 {
  		ret = fac(n-1) + fac(n-2)
  	} else if n == 1 || n == 2 {
  		ret = 1
  	}
  	//fmt.Println(ret)
  	return ret
  }
  ```

  对于 斐波那契 数列，递归方法过于消费时间，很多数据都会重复计算，时间复杂度为 O(2^n),  其实优化方案 可以用 散列表去存储已经计算过的数据，这样会大大减少运算时间， 可以采用 动态规划方案解决这个问题，本章节暂时负责递归方案，其他章节会另行提到此案例。

-  求阶乘

  **题：** 一个数从 n * (n-1) * (n-2) * ... * 1 的值

  **解:**  满足 `n ==1`  时候终止条件 ;   满足问题的解可以分解为几个子问题的解；满足  `n * getFactorial(n-1) = getFactorial(n)` 的求解思路完全一样的要素。

  模型为：
  $$
  getFactorial(n) =\left\{
  \begin{matrix}
   n  \ \ *  \ \ getFactorial(n-1) \ \ \ n>1
   \\   \\
   1   \ \ \ \ n == 1
  \end{matrix}
  \right.
  $$
  核心函数 getFactorial(n) 代码实现 （完整实现-参考 code\golang\递归\factorial.go）：

  ```go
  func getFactorial(n int) int {
  	var ret int
  	if n == 1 {
  		ret = 1
  	} else if n > 1 {
  		ret = n * getFactorial(n-1)
  	}
  	return ret
  }
  ```

  

- 链表反转

  **题：** 反转单链表 head->1->2->3->4->5->6->7->nil 

  **解:**   满足 `node->next==nil`  时候终止条件 ;   满足问题的解可以分解为几个子问题的解；满足 的求解思路完全一样的要素。

  模型为：
  $$
  reverse(node) =\left\{
  \begin{matrix}
   \ \ reverse(node.next) \\ node.next.next = node
  		\\ node.next = nil \\   
   \\   \\
   1   \ \ \ \ node.nil == nil
  \end{matrix}
  \right.
  $$
  核心函数 reverse(node) 代码实现 （完整实现-参考 code\golang\递归\linkReverse.go）：

  ```go
  func reverse(node *Node) *Node {
  	if node.next == nil {
  		return node
  	} else {
  		newHead := reverse(node.next)
  		node.next.next = node
  		node.next = nil
  		return newHead
  	}
  }
  ```

  

- 汉诺塔问题

  

