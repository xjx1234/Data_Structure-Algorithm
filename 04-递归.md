## 递归算法

### 递归概述

简单的说，**递归**指一个函数直接或者间接调用自己。

递归是一种数学上分而自治的思想。

- 将原问题分解为规模较小的问题进行处理，分解后的问题与原问题类型完全相同，当规模较小。通过小规模问题的解，能够轻易求得原生问题的解。
- 问题的分解时有限的，当边界条件不能满足时，分解问题（继续递归），当边界条件满足时，直接求解（递归结束）。

使用递归必须满足三个条件：

1.  递归必须有一个明确的终止条件
2.  该函数所处理的数据规模递减, 求解思路完全一样
3.   一个问题的解可以分解为几个子问题的解

递归模型的一般表示法：


$$
f(n) =\left\{
\begin{matrix}
 a{_n}  \ \ \bigcup  \ \ f(n-1) \ \ \ n>1
 \\   \\
 a1 
\end{matrix}
\right.
$$

### 应用的递归解决方案

- 求和递归的实现

  **题：** `SUM(n) = 1 + 2 + 3 + ... + n` 

  **解：**

  首先按着递归模型以及递归三要素来分析题目，求和递归的明确终止条件为 `n == 1` ; 求和的递归相同解决思路是： `n + SUM(n-1)` ；也符合可以分解几个子问题解决。求和的递归模型为：
  $$
  SUM(n) =\left\{
  \begin{matrix}
   n  \ \ +  \ \ SUM(n-1) \ \ \ n>1
   \\   \\
   1   \ \ \ \ n == 1
  \end{matrix}
  \right.
  $$
  核心 SUM(n) 的 代码实现 （完整实现-参考 code\golang\递归\sum.go）：

  ```go
  func sum(n int) int {
  	s := 0
  	if n == 1 {
  		s = s + n
  	} else if n > 1 {
  		s = n + sum(n-1)
  	}
  	return s
  }
  ```

  

- 斐波那契数列的实现

  **题：** 写一个函数，输入 `n` ，求斐波那契（Fibonacci）数列的第 `n` 项。斐波那契数列的数据结构如下：

  > 1，1，2，3，5，8，13，21，34， ......

  **解：** 

  满足 `n == 2 || n ==1`  时候终止条件 ;   满足问题的解可以分解为几个子问题的解；满足  `fac(n-1) + f(n-2) = fac(n)` 的求解思路完全一样的要素。

  模型为：
  $$
  fac(n) =\left\{
  \begin{matrix}
   fac(n-1) \ \ +  \ \ fac(n-2) \ \ \ n>=3
   \\   \\
   1   \ \ \ \ n == 2
   \\   \\
   1   \ \ \ \ n == 1
  \end{matrix}
  \right.
  $$
  核心函数 fac(n) 代码实现：

  ```go
  
  ```

  



-  求阶乘

  

- 链表反转

  

- 汉诺塔问题

  

